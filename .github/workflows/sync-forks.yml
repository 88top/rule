name: Sync Fork from Upstream

on:
  schedule:
    # 每天北京时间 03:00 和 15:00 自动运行
    - cron: '0 19 * * *'  # UTC 19:00 = 北京时间次日 03:00
    - cron: '0 7 * * *'   # UTC 07:00 = 北京时间当天 15:00
  workflow_dispatch:
    inputs:
      upstream_repos:
        description: |
          要同步的源仓库 (格式: owner/repo)
          多个用逗号分隔，留空为当前仓库
          输入 'all' 使用默认配置
        required: false
        default: 'all'
      force_sync:
        description: '强制同步（忽略时间检查）'
        type: boolean
        default: false

# 需要写权限来推送分支
permissions:
  contents: write

jobs:
  sync-repository:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # 获取所有分支历史
        
    - name: Setup Git
      run: |
        git config --global user.name 'github-actions[bot]'
        git config --global user.email 'github-actions[bot]@users.noreply.github.com'
        git config --global pull.rebase false
        
    - name: Install jq (JSON processor)
      run: |
        sudo apt-get update
        sudo apt-get install -y jq
        
    - name: Determine upstream repository
      id: get-upstream
      env:
        INPUT_REPOS: ${{ inputs.upstream_repos }}
      run: |
        echo "输入参数: '$INPUT_REPOS'"
        
        if [ -z "$INPUT_REPOS" ]; then
          echo "输入为空，使用当前仓库的上游"
          
          # 对于 OpenClash 仓库，默认上游是 vernesong/OpenClash
          CURRENT_REPO="${{ github.repository }}"
          REPO_NAME=$(basename "$CURRENT_REPO")
          
          if [ "$REPO_NAME" == "OpenClash" ]; then
            UPSTREAM_REPO="vernesong/OpenClash"
          else
            # 尝试获取上游信息
            API_RESPONSE=$(curl -s \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/$CURRENT_REPO" || echo "{}")
            
            PARENT_REPO=$(echo "$API_RESPONSE" | jq -r '.parent.full_name // empty')
            
            if [ -n "$PARENT_REPO" ] && [ "$PARENT_REPO" != "null" ]; then
              UPSTREAM_REPO="$PARENT_REPO"
            else
              UPSTREAM_REPO=""
            fi
          fi
          
          if [ -z "$UPSTREAM_REPO" ]; then
            echo "⚠️ 无法自动检测上游仓库，请手动指定"
            echo "UPSTREAM_REPO=" >> $GITHUB_OUTPUT
            echo "HAS_UPSTREAM=false" >> $GITHUB_OUTPUT
          else
            echo "检测到上游: $UPSTREAM_REPO"
            echo "UPSTREAM_REPO=$UPSTREAM_REPO" >> $GITHUB_OUTPUT
            echo "HAS_UPSTREAM=true" >> $GITHUB_OUTPUT
          fi
          
        elif [ "$INPUT_REPOS" == "all" ]; then
          echo "输入 'all'，使用默认配置"
          # 对于 OpenClash，默认上游是 vernesong/OpenClash
          echo "UPSTREAM_REPO=vernesong/OpenClash" >> $GITHUB_OUTPUT
          echo "HAS_UPSTREAM=true" >> $GITHUB_OUTPUT
          
        else
          echo "使用指定仓库: $INPUT_REPOS"
          
          # 如果包含逗号，只取第一个
          if [[ "$INPUT_REPOS" == *","* ]]; then
            FIRST_REPO=$(echo "$INPUT_REPOS" | cut -d',' -f1 | xargs)
            echo "多个仓库只同步第一个: $FIRST_REPO"
            echo "UPSTREAM_REPO=$FIRST_REPO" >> $GITHUB_OUTPUT
          else
            echo "UPSTREAM_REPO=$INPUT_REPOS" >> $GITHUB_OUTPUT
          fi
          echo "HAS_UPSTREAM=true" >> $GITHUB_OUTPUT
        fi
        
    - name: Sync from upstream
      id: sync-upstream
      if: steps.get-upstream.outputs.HAS_UPSTREAM == 'true'
      env:
        UPSTREAM_REPO: ${{ steps.get-upstream.outputs.UPSTREAM_REPO }}
        FORCE_SYNC: ${{ inputs.force_sync }}
      run: |
        echo "开始同步上游仓库: $UPSTREAM_REPO"
        
        # 添加上游远程仓库
        git remote add upstream "https://github.com/$UPSTREAM_REPO.git" 2>/dev/null || \
          git remote set-url upstream "https://github.com/$UPSTREAM_REPO.git"
        
        # 获取所有上游分支
        echo "获取上游所有分支..."
        git fetch upstream
        
        # 获取所有分支列表
        BRANCHES=$(git branch -r | grep 'upstream/' | grep -v 'HEAD' | sed 's/upstream\///')
        
        if [ -z "$BRANCHES" ]; then
          echo "⚠️ 未找到任何分支"
          exit 0
        fi
        
        echo "找到以下分支:"
        echo "$BRANCHES"
        
        # 保存当前分支
        ORIGINAL_BRANCH=$(git branch --show-current 2>/dev/null || echo "")
        
        # 同步每个分支
        SYNC_RESULTS=""
        for BRANCH in $BRANCHES; do
          echo "正在同步分支: $BRANCH"
          
          # 清理分支名
          BRANCH=$(echo "$BRANCH" | xargs)
          
          if [ -z "$BRANCH" ]; then
            continue
          fi
          
          # 检查本地是否存在该分支
          if git show-ref --quiet "refs/heads/$BRANCH"; then
            echo "分支 $BRANCH 已存在，切换到并合并..."
            git checkout "$BRANCH"
            if git merge --no-edit upstream/"$BRANCH"; then
              SYNC_RESULTS="${SYNC_RESULTS}✅ $BRANCH: 合并成功\n"
            else
              # 合并失败，尝试重置
              git reset --hard upstream/"$BRANCH"
              SYNC_RESULTS="${SYNC_RESULTS}⚠️ $BRANCH: 强制更新\n"
            fi
          else
            echo "创建新分支: $BRANCH"
            git checkout -b "$BRANCH" upstream/"$BRANCH"
            SYNC_RESULTS="${SYNC_RESULTS}➕ $BRANCH: 新建分支\n"
          fi
          
          # 推送到 origin
          echo "推送分支 $BRANCH..."
          if git push origin "$BRANCH"; then
            SYNC_RESULTS="${SYNC_RESULTS}  └→ 推送成功\n"
          else
            SYNC_RESULTS="${SYNC_RESULTS}  └→ ❌ 推送失败\n"
          fi
          
          echo "✅ 分支 $BRANCH 同步完成"
        done
        
        # 切换回原始分支
        if [ -n "$ORIGINAL_BRANCH" ]; then
          git checkout "$ORIGINAL_BRANCH" 2>/dev/null || true
        fi
        
        echo "🎉 所有分支同步完成!"
        
        # 输出同步结果
        echo "SYNC_RESULTS<<EOF" >> $GITHUB_OUTPUT
        echo "$SYNC_RESULTS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
    - name: Create summary
      if: always()
      env:
        HAS_UPSTREAM: ${{ steps.get-upstream.outputs.HAS_UPSTREAM }}
        UPSTREAM_REPO: ${{ steps.get-upstream.outputs.UPSTREAM_REPO }}
        SYNC_RESULTS: ${{ steps.sync-upstream.outputs.SYNC_RESULTS }}
      run: |
        echo "## 📊 上游同步报告" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # 检查是否有上游仓库
        if [ "$HAS_UPSTREAM" == "true" ]; then
          echo "**🔗 上游仓库:** $UPSTREAM_REPO" >> $GITHUB_STEP_SUMMARY
          echo "**🕐 同步时间:** $(date '+%Y-%m-%d %H:%M:%S')" >> $GITHUB_STEP_SUMMARY
          echo "**⚙️ 触发方式:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          
          # 检查同步是否执行
          if [ "${{ job.status }}" == "success" ]; then
            if [ -n "$SYNC_RESULTS" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### ✅ 同步结果" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "$SYNC_RESULTS" >> $GITHUB_STEP_SUMMARY
              echo "🎉 同步完成！" >> $GITHUB_STEP_SUMMARY
            else
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### ⏭️ 没有需要同步的更改" >> $GITHUB_STEP_SUMMARY
              echo "上游仓库没有新分支或分支已是最新。" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ❌ 同步失败" >> $GITHUB_STEP_SUMMARY
            echo "请检查日志获取详细信息。" >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "### ⚠️ 未找到上游仓库" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "请提供有效的上游仓库地址，格式为：owner/repo" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "例如：" >> $GITHUB_STEP_SUMMARY
          echo "- `vernesong/OpenClash`" >> $GITHUB_STEP_SUMMARY
          echo "- 留空（自动检测）" >> $GITHUB_STEP_SUMMARY
          echo "- `all`（使用默认配置）" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**📅 下次自动同步时间:**" >> $GITHUB_STEP_SUMMARY
        echo "- 北京时间 03:00（UTC 前一天 19:00）" >> $GITHUB_STEP_SUMMARY
        echo "- 北京时间 15:00（UTC 当天 07:00）" >> $GITHUB_STEP_SUMMARY
