name: Update All Fork Repositories

on:
  schedule:
    # 每天北京时间 03:00 和 15:00 自动运行，同步所有fork仓库
    - cron: '0 19 * * *'  # UTC 19:00 = 北京时间次日 03:00
    - cron: '0 7 * * *'   # UTC 07:00 = 北京时间当天 15:00
  workflow_dispatch:
    inputs:
      repositories:
        description: |
          要更新的仓库：
          留空 - 仅更新当前仓库
          all - 更新所有fork仓库
          指定 - owner/repo,owner2/repo2
        required: false
        default: ""

permissions:
  contents: read

jobs:
  update-repos:
    runs-on: ubuntu-latest
    
    steps:
    - name: 检查配置
      run: |
        if [ -z "${{ secrets.AUTH_PAT }}" ]; then
          echo "❌ 请先配置 AUTH_PAT"
          echo "在仓库 Settings → Secrets → Actions 中添加 PAT"
          echo "PAT 需要 repo 权限"
          exit 1
        fi
        
    - name: 安装依赖
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl git
        
    - name: 确定更新模式
      id: determine-mode
      run: |
        echo "触发事件: ${{ github.event_name }}"
        
        if [ "${{ github.event_name }}" = "schedule" ]; then
          # 定时任务：默认更新所有fork仓库
          echo "🕐 定时任务触发，使用 'all' 模式"
          echo "mode=all" >> $GITHUB_OUTPUT
        else
          # 手动触发：使用用户输入
          USER_INPUT="${{ github.event.inputs.repositories }}"
          echo "👆 手动触发，用户输入: '$USER_INPUT'"
          
          if [ -z "$USER_INPUT" ]; then
            echo "用户输入为空，更新当前仓库"
            echo "mode=current" >> $GITHUB_OUTPUT
          elif [ "$USER_INPUT" = "all" ]; then
            echo "用户输入 'all'，更新所有fork仓库"
            echo "mode=all" >> $GITHUB_OUTPUT
          else
            echo "用户指定仓库: $USER_INPUT"
            echo "mode=manual" >> $GITHUB_OUTPUT
          fi
        fi
        
    - name: 获取所有fork仓库列表（如果是all模式）
      if: steps.determine-mode.outputs.mode == 'all'
      id: get-all-fork-repos
      env:
        GH_TOKEN: ${{ secrets.AUTH_PAT }}
      run: |
        echo "🔍 正在获取您所有的fork仓库..."
        
        page=1
        ALL_FORK_REPOS=""
        
        while true; do
          echo "获取第 $page 页..."
          RESPONSE=$(curl -s -H "Authorization: token $GH_TOKEN" \
                        "https://api.github.com/user/repos?per_page=100&page=$page&type=owner&sort=full_name")
          
          # 检查API响应
          if echo "$RESPONSE" | jq 'type' 2>/dev/null | grep -q "array"; then
            # 提取fork仓库
            FORK_REPOS=$(echo "$RESPONSE" | jq -r '.[] | select(.fork == true) | .full_name' | tr '\n' ',')
            
            if [ -z "$FORK_REPOS" ] || [ "$FORK_REPOS" = "" ]; then
              echo "没有更多fork仓库"
              break
            fi
            
            ALL_FORK_REPOS="${ALL_FORK_REPOS}${FORK_REPOS}"
            REPO_COUNT=$(echo "$FORK_REPOS" | tr ',' '\n' | wc -l)
            echo "第 $page 页找到 $REPO_COUNT 个fork仓库"
            
            page=$((page + 1))
            
            if [ $page -gt 5 ]; then
              echo "⚠️ 已获取最多 500 个仓库"
              break
            fi
            
            sleep 1
          else
            echo "API 响应异常，跳过"
            break
          fi
        done
        
        if [ -n "$ALL_FORK_REPOS" ]; then
          ALL_FORK_REPOS=${ALL_FORK_REPOS%,}
          TOTAL_COUNT=$(echo "$ALL_FORK_REPOS" | tr ',' '\n' | wc -l)
          echo "fork_repositories=$ALL_FORK_REPOS" >> $GITHUB_OUTPUT
          echo "✅ 共找到 $TOTAL_COUNT 个fork仓库"
        else
          echo "fork_repositories=" >> $GITHUB_OUTPUT
          echo "⚠️ 未找到任何fork仓库"
        fi
        
    - name: 准备仓库列表
      id: prepare-repos
      run: |
        MODE="${{ steps.determine-mode.outputs.mode }}"
        USER_INPUT="${{ github.event.inputs.repositories }}"
        
        echo "准备模式: $MODE"
        
        if [ "$MODE" = "all" ]; then
          # 使用所有fork仓库
          FINAL_REPOS="${{ steps.get-all-fork-repos.outputs.fork_repositories }}"
          if [ -z "$FINAL_REPOS" ]; then
            echo "⚠️ 未找到fork仓库，更新当前仓库"
            FINAL_REPOS="${{ github.repository }}"
          else
            echo "🚀 将更新所有fork仓库"
          fi
        elif [ "$MODE" = "current" ]; then
          # 仅当前仓库
          FINAL_REPOS="${{ github.repository }}"
          echo "📍 将更新当前仓库: $FINAL_REPOS"
        else
          # 手动指定的仓库
          FINAL_REPOS="$USER_INPUT"
          echo "🎯 将更新指定仓库: $FINAL_REPOS"
        fi
        
        # 清理格式
        FINAL_REPOS=$(echo "$FINAL_REPOS" | tr -d ' ' | sed 's/,,*/,/g' | sed 's/^,//' | sed 's/,$//')
        
        echo "repositories=$FINAL_REPOS" >> $GITHUB_OUTPUT
        REPO_COUNT=$(echo "$FINAL_REPOS" | tr ',' '\n' | wc -l)
        echo "repo_count=$REPO_COUNT" >> $GITHUB_OUTPUT
        
    - name: 更新仓库
      env:
        REPOSITORIES: ${{ steps.prepare-repos.outputs.repositories }}
        GH_TOKEN: ${{ secrets.AUTH_PAT }}
      run: |
        echo "🔄 开始更新仓库..."
        echo "仓库列表: $REPOSITORIES"
        echo "总仓库数: ${{ steps.prepare-repos.outputs.repo_count }}"
        
        if [ -z "$REPOSITORIES" ]; then
          echo "❌ 错误：未指定要更新的仓库"
          exit 1
        fi
        
        IFS=',' read -ra REPO_ARRAY <<< "$REPOSITORIES"
        
        UPDATED_REPOS=0
        UP_TO_DATE_REPOS=0
        SKIPPED_REPOS=0
        FAILED_REPOS=0
        
        for TARGET_REPO in "${REPO_ARRAY[@]}"; do
          echo ""
          echo "========================================"
          echo "🔄 更新仓库 ($((UPDATED_REPOS + UP_TO_DATE_REPOS + SKIPPED_REPOS + FAILED_REPOS + 1))/${#REPO_ARRAY[@]}): $TARGET_REPO"
          echo "========================================"
          
          # 跳过空值
          if [ -z "$TARGET_REPO" ]; then
            echo "跳过空仓库名"
            SKIPPED_REPOS=$((SKIPPED_REPOS + 1))
            continue
          fi
          
          # 创建临时目录
          TEMP_DIR=$(mktemp -d)
          cd "$TEMP_DIR"
          
          # 克隆目标仓库（使用PAT）
          echo "📥 克隆仓库..."
          if ! git clone "https://x-access-token:$GH_TOKEN@github.com/$TARGET_REPO.git" . 2>/dev/null; then
            echo "❌ 克隆仓库失败，可能没有权限"
            cd /
            rm -rf "$TEMP_DIR"
            FAILED_REPOS=$((FAILED_REPOS + 1))
            continue
          fi
          
          # 设置Git用户
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # 获取上游仓库信息
          echo "📡 获取上游仓库信息..."
          REPO_INFO=$(curl -s -H "Authorization: token $GH_TOKEN" \
                      "https://api.github.com/repos/$TARGET_REPO")
          
          PARENT_REPO=$(echo "$REPO_INFO" | jq -r '.parent.full_name // empty')
          
          if [ -z "$PARENT_REPO" ] || [ "$PARENT_REPO" = "null" ]; then
            echo "⚠️ $TARGET_REPO 不是fork仓库，跳过"
            cd /
            rm -rf "$TEMP_DIR"
            SKIPPED_REPOS=$((SKIPPED_REPOS + 1))
            continue
          fi
          
          echo "✅ 上游仓库: $PARENT_REPO"
          
          # 添加上游远程
          echo "🔗 添加上游仓库..."
          git remote add upstream "https://github.com/$PARENT_REPO.git" 2>/dev/null || true
          
          # 获取所有上游分支
          echo "📡 获取上游分支..."
          if ! git fetch upstream 2>/dev/null; then
            echo "❌ 获取上游分支失败，可能上游仓库不存在"
            cd /
            rm -rf "$TEMP_DIR"
            FAILED_REPOS=$((FAILED_REPOS + 1))
            continue
          fi
          
          # 获取所有上游分支名
          UPSTREAM_BRANCHES=$(git branch -r | grep 'upstream/' | sed 's/upstream\///' | grep -v HEAD)
          
          if [ -z "$UPSTREAM_BRANCHES" ]; then
            echo "⚠️ 未找到上游分支，跳过"
            cd /
            rm -rf "$TEMP_DIR"
            SKIPPED_REPOS=$((SKIPPED_REPOS + 1))
            continue
          fi
          
          echo "🌿 找到上游分支: $UPSTREAM_BRANCHES"
          
          # 保存原始分支
          ORIG_BRANCH=$(git branch --show-current 2>/dev/null || echo "")
          
          # 更新每个分支（不推送）
          UPDATED_BRANCHES=0
          UP_TO_DATE_BRANCHES=0
          
          for BRANCH in $UPSTREAM_BRANCHES; do
            BRANCH=$(echo "$BRANCH" | xargs)
            [ -z "$BRANCH" ] && continue
            
            echo "  处理分支: $BRANCH"
            
            # 检查本地是否有这个分支
            if git show-ref --verify --quiet "refs/heads/$BRANCH"; then
              echo "    分支已存在"
              git checkout "$BRANCH" 2>/dev/null || git checkout -b "$BRANCH" "upstream/$BRANCH"
              
              # 获取本地和上游的提交哈希
              LOCAL_HASH=$(git rev-parse HEAD 2>/dev/null || echo "")
              UPSTREAM_HASH=$(git rev-parse "upstream/$BRANCH" 2>/dev/null || echo "")
              
              if [ -z "$LOCAL_HASH" ] || [ -z "$UPSTREAM_HASH" ]; then
                echo "    ⚠️ 无法获取提交哈希，跳过"
                continue
              fi
              
              if [ "$LOCAL_HASH" = "$UPSTREAM_HASH" ]; then
                echo "    ✅ 已是最新"
                UP_TO_DATE_BRANCHES=$((UP_TO_DATE_BRANCHES + 1))
              else
                echo "    🔄 发现更新"
                echo "      本地: $LOCAL_HASH"
                echo "      上游: $UPSTREAM_HASH"
                
                # 合并上游更新（不推送）
                if git merge --no-edit "upstream/$BRANCH" 2>/dev/null; then
                  echo "    ✅ 合并成功"
                else
                  echo "    ⚠️ 合并冲突，使用上游版本"
                  git reset --hard "upstream/$BRANCH"
                fi
                
                UPDATED_BRANCHES=$((UPDATED_BRANCHES + 1))
              fi
            else
              echo "    🌱 创建新分支（仅本地）"
              git checkout -b "$BRANCH" "upstream/$BRANCH"
              UPDATED_BRANCHES=$((UPDATED_BRANCHES + 1))
            fi
          done
          
          # 恢复原始分支
          if [ -n "$ORIG_BRANCH" ]; then
            git checkout "$ORIG_BRANCH" 2>/dev/null || true
          fi
          
          # 清理
          cd /
          rm -rf "$TEMP_DIR"
          
          if [ $UPDATED_BRANCHES -gt 0 ]; then
            echo "✅ $TARGET_REPO 更新完成 ($UPDATED_BRANCHES 个分支有更新)"
            UPDATED_REPOS=$((UPDATED_REPOS + 1))
          else
            echo "⏭️ $TARGET_REPO 已是最新 ($UP_TO_DATE_BRANCHES 个分支已最新)"
            UP_TO_DATE_REPOS=$((UP_TO_DATE_REPOS + 1))
          fi
        done
        
        echo ""
        echo "🎉 更新完成（本地更新，未推送）"
        echo "📊 统计："
        echo "  ✅ 有更新的仓库: $UPDATED_REPOS"
        echo "  ⏭️  已最新的仓库: $UP_TO_DATE_REPOS"
        echo "  🔄 跳过的仓库: $SKIPPED_REPOS"
        echo "  ❌ 失败的仓库: $FAILED_REPOS"
        
        # 设置输出
        echo "updated_repos=$UPDATED_REPOS" >> $GITHUB_OUTPUT
        echo "up_to_date_repos=$UP_TO_DATE_REPOS" >> $GITHUB_OUTPUT
        echo "skipped_repos=$SKIPPED_REPOS" >> $GITHUB_OUTPUT
        echo "failed_repos=$FAILED_REPOS" >> $GITHUB_OUTPUT
        
    - name: 生成报告
      if: always()
      env:
        MODE: ${{ steps.determine-mode.outputs.mode }}
        REPO_COUNT: ${{ steps.prepare-repos.outputs.repo_count }}
        UPDATED_REPOS: ${{ steps.update-repos.outputs.updated_repos || 0 }}
        UP_TO_DATE_REPOS: ${{ steps.update-repos.outputs.up_to_date_repos || 0 }}
        SKIPPED_REPOS: ${{ steps.update-repos.outputs.skipped_repos || 0 }}
        FAILED_REPOS: ${{ steps.update-repos.outputs.failed_repos || 0 }}
      run: |
        echo "## 📊 仓库更新报告" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**更新时间:** $(date '+%Y-%m-%d %H:%M:%S')" >> $GITHUB_STEP_SUMMARY
        echo "**触发方式:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**更新模式:** $MODE" >> $GITHUB_STEP_SUMMARY
        echo "**目标仓库数:** $REPO_COUNT 个" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ job.status }}" = "success" ]; then
          echo "**状态:** ✅ 更新任务执行完成" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📈 更新统计" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| 状态 | 仓库数 | 说明 |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|------|" >> $GITHUB_STEP_SUMMARY
          echo "| ✅ 有更新 | $UPDATED_REPOS | 本地分支已更新（未推送） |" >> $GITHUB_STEP_SUMMARY
          echo "| ⏭️ 已最新 | $UP_TO_DATE_REPOS | 所有分支已是最新 |" >> $GITHUB_STEP_SUMMARY
          echo "| 🔄 跳过 | $SKIPPED_REPOS | 非fork仓库或无分支 |" >> $GITHUB_STEP_SUMMARY
          echo "| ❌ 失败 | $FAILED_REPOS | 权限或网络问题 |" >> $GITHUB_STEP_SUMMARY
          echo "| 📦 总计 | $REPO_COUNT | 目标仓库总数 |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### 📝 说明" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. **仅本地更新**：更新只在 GitHub Actions 运行环境中生效" >> $GITHUB_STEP_SUMMARY
          echo "2. **未推送**：没有执行 `git push`，不会触发其他仓库的 Actions" >> $GITHUB_STEP_SUMMARY
          echo "3. **定时任务**：自动同步所有fork仓库的所有分支" >> $GITHUB_STEP_SUMMARY
          echo "4. **手动触发**：支持多种输入方式" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### 🔄 下次自动更新时间" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- 北京时间 03:00（UTC 前一天 19:00）" >> $GITHUB_STEP_SUMMARY
          echo "- 北京时间 15:00（UTC 当天 07:00）" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> ⚠️ 注意：定时任务默认更新所有fork仓库，如需修改请在手动触发时指定" >> $GITHUB_STEP_SUMMARY
        else
          echo "**状态:** ❌ 更新任务执行失败" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "请查看详细日志了解错误信息。" >> $GITHUB_STEP_SUMMARY
        fi

# ========================================
# 1、不触发其他仓库的 Actions，直接调用 GitHub 官方API：POST /repos/{owner}/{repo}/merge-upstream，这就是网页上“Sync fork”按钮的底层机制，服务器端直接 fast-forward 或 merge 默认分支，不会产生 push 事件，因此绝对不会触发 fork 仓库里的 on: push workflows。
# 2、纯API调用，无需任何克隆操作，没有临时目录、没有下载代码，40个仓库预计1-2分钟内完成（甚至更快）。
# 3、API只在有更新时才修改分支，冲突时自动返回409并跳过，不会强制合并，无更新时返回422"已是最新"。
# 4、日志超级详细：成功/跳过/失败统计、每仓库状态一目了然，便于监控 Actions 日志。
# 5、手动模式完美：支持指定多个仓库：owner/repo1,owner/repo2；留空只同步当前仓库；输入all同步所有fork。
# 6、自动全量同步：scheduled 时同步所有 fork，每天两次（北京 3:00 和 15:00），自动模式使用all策略。
# 7、使用 AUTH_PAT（已有repo, workflow权限），自动验证认证状态，API调用安全可靠。
# 8、https://github.com/wei/pull，是一个第三方开源 GitHub App，通过自动创建并合并 PR 将 upstream 同步到 fork。但 PR 的创建与合并会触发 push / pull_request 事件，从而可能执行你 fork 仓库中的 GitHub Actions（尤其是 on: push、on: pull_request），这一点需要尽量避免
# ========================================
